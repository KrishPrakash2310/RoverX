Serial Peripheral Interface (SPI) is a synchronous serial communication protocol used to transfer data between microcontrollers and peripheral devices. It is widely used due to its simplicity and high-speed data transfer capabilities. 
### How SPI Works
#### Basic Components
1. **Master and Slave**: SPI operates with a single master device and one or more slave devices.
2. **Four Main Signals**:
   - **SCLK (Serial Clock)**: Generated by the master to synchronize data transmission.
   - **MOSI (Master Out Slave In)**: Data line for master to send data to slave.
   - **MISO (Master In Slave Out)**: Data line for slave to send data to master.
   - **SS (Slave Select)**: Active-low signal to select the slave device for communication.

#### Communication Process
1. **Clock Signal**: The master generates the SCLK signal to synchronize the data exchange.
2. **Data Transfer**:
   - **Master to Slave**: Data is sent from the master to the slave over the MOSI line.
   - **Slave to Master**: Data is sent from the slave to the master over the MISO line.
3. **Slave Selection**: The master activates the SS line (pulls it low) to select the appropriate slave device for communication.
4. **Full-Duplex Communication**: SPI can simultaneously send and receive data, making it a full-duplex protocol.
5. **Data Frames**: Data is transmitted in frames, typically 8-bit bytes, but can be configured for different sizes.

### Advantages of SPI Over CAN
1. **Speed**:
   - SPI can operate at much higher data rates than CAN, making it suitable for applications requiring rapid data transfer.
2. **Simplicity**:
   - SPI is simpler to implement compared to CAN, with fewer protocol overheads and simpler error checking.
3. **Full-Duplex Communication**:
   - SPI supports full-duplex communication, allowing simultaneous data transmission and reception, which is not possible with CAN.
4. **Multiple Devices**:
   - SPI can connect multiple slave devices with individual SS lines for each slave, allowing for straightforward device management.

### Disadvantages of SPI Compared to CAN
1. **Scalability**:
   - SPI requires separate SS lines for each slave device, making it less scalable for applications with many devices compared to CAN, which uses a shared bus for all nodes.
2. **Wiring Complexity**:
   - SPI requires more wires (at least four) compared to CANâ€™s two-wire bus, increasing wiring complexity and cost.
3. **Error Detection and Handling**:
   - CAN has more robust error detection and handling mechanisms, including CRC checks, bit monitoring, and error frames, making it more reliable in noisy environments.
4. **Bus Arbitration**:
   - CAN supports multi-master operation with priority-based message arbitration, allowing multiple nodes to communicate efficiently. SPI typically operates with a single master.
5. **Distance and Noise Immunity**:
   - CAN is designed for longer distances and higher noise environments, with differential signaling to reduce EMI. SPI is more suited for short-distance communication within a device or between closely situated devices.

### Use Cases
- **SPI**: Preferred for high-speed, short-distance communication within a device or between peripherals (e.g., sensors, displays, memory chips).
- **CAN**: Ideal for automotive, industrial, and other applications requiring robust, long-distance communication in noisy environments with multiple nodes (e.g., vehicle control systems, factory automation).

### Summary
SPI is a high-speed, simple protocol suitable for short-distance, high-speed data transfer between a master and multiple slave devices. It offers significant advantages in speed and simplicity over CAN. However, CAN excels in scalability, error handling, noise immunity, and multi-master capabilities, making it better suited for complex, noisy, and distributed systems.
\
### CONCLUSION
So overall CAN is a better choice. 
***(1)*** Since our rover is a multi-master setup(and not a typical master-slave setup) and in such configurations CAN is the best choice.

***(2)*** On the rover there will be a stream of inputs/feedbacks going to the JETSON, but we need to prioritize them according to our needs(i.e some Arbitration is needed). This can only be implemented by CAN.

***(3)*** Also we need a protocol immune to the noise/EMI from other factors.

***(4)*** We need inbuilt error handling feature of CAN.